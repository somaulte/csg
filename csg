#!/usr/bin/env bash
#
# csg: generate a tinted base16 colorscheme using a single colormask.
# https://gitlab.com/ogdenjosh/csg
#
# MIT License
#
# Copyright (c) 2018-2019 Joshua Ogden <ogdenjosh@gmail.com>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# Except as contained in this notice, the name(s) of the above copyright
# holders shall not be used in advertising or otherwise to promote the sale, use
# or other dealings in this Software without prior written authorization.

# If the $CSG_DEBUG environment variable is set to 'true' or '1', enter debug mode
[[ "$CSG_DEBUG" =~ ('true'|'1') ]] && set -x

# Disable unicode for performance
LC_ALL=C
LANG=C

# List colors 0-15 of base16 colorscheme to work against
colors=(
	'#1D1F23'
	'#A54B4B'
	'#6DA741'
	'#836539'
	'#216590'
	'#5C3466'
	'#1AAD95'
	'#B6B6B6'
	'#2D3135'
	'#D76F68'
	'#96CB5C'
	'#C59B3D'
	'#21A4DF'
	'#AD7FA8'
	'#68CBC0'
	'#D3D7CF'
)

# Usage: deconstruct_i [input color]
# Ouputs color channels converted from hexadecimal input colors to decimal
deconstruct_i() {
	local out=(
		"$(( 16#${1:1:2} ))"
		"$(( 16#${1:3:2} ))"
		"$(( 16#${1:5:2} ))"
	)
	echo "${out[@]}"
}

# Usage: deconstruct_b16 [index]
# Ouputs color channels converted from hexadecimal base16 colors to decimal
deconstruct_b16() {
	local c="${colors[$1]}"
	local out=(
		"$(( 16#${c:1:2} ))"
		"$(( 16#${c:3:2} ))"
		"$(( 16#${c:5:2} ))"
	)
	echo "${out[@]}"
}

# Formula:
# i = ${rgb1}; b = ${rgb2}; c = ${weight}
# ( ic + b(100 - c) )
#
# Usage: merge [weight] [red1] [green1] [blue1] [red2] [green2] [blue2]
# Outputs color channel values between two colors given as RGB color channels
merge() {
	local weight="$1"
	local out=(
		"$(( ( ( weight * ${2} ) + ( ( 100 - weight ) * ${5} ) ) / 100 ))"
		"$(( ( ( weight * ${3} ) + ( ( 100 - weight ) * ${6} ) ) / 100 ))"
		"$(( ( ( weight * ${4} ) + ( ( 100 - weight ) * ${7} ) ) / 100 ))"
	)
	echo "${out[@]}"
}

# Formula:
# l = ${HSL[Lightness]}
# ( l + 40 )
#
# Formula taken from dylanaraps's `Pure Bash Bible`, issue #90
# https://github.com/dylanaraps/pure-bash-bible/issues/90
#
# Usage: hilight [red] [blue] [green]
# Increases a color's Lightness in the HSL colorspace and outputs RGB color channels
hilight() {
	local min=100
	local max=0
	local r="$(( ( ${1} * 100 ) / 255 ))"
	local g="$(( ( ${2} * 100 ) / 255 ))"
	local b="$(( ( ${3} * 100 ) / 255 ))"
	# Set min/max to our least and greatest rgb decimal values
	min="$(( r < min ? r : min ))"
	max="$(( r > max ? r : max ))"
	min="$(( g < min ? g : min ))"
	max="$(( g > max ? g : max ))"
	min="$(( b < min ? b : min ))"
	max="$(( b > max ? b : max ))"
	# Calculate Saturation first, as Hue is dependent on it
	local s="$(( min == max ? 0 : l < 50 ? (max - min) * 100 / (max + min) : (max - min) * 100 / (200 - max - min) ))"
	local h="$(( s == 0 ? 0 : r == max ? (g - b) * 100 / (max - min) : g == max ? 200 + (b - r) * 100 / (max - min) : b == max ? 400 + (r - g) * 100 / (max - min) : 0 ))"
	# If Hue at this point is negative, rotate it around by adding 600
	h="$(( h < 0 ? 600 + h : h ))"
	l="$(( ( min + max ) / 2 ))"
	# Raise ${colors[{8..15}]}'s Lightness value by 40 to hilight them
	# Not sure what's going on here.. but the conversion produces Lightness + 10
	# so it should only be increased by 30
	l="$(( l < 70 ? l + 30 : 100 ))"
	# Convert back to RGB
	local c="$(( ( ( 100 - (( l >= 50 ? 2 * l - 100 : -2 * l - 100 )) ) * s ) / 100 ))"
	local x="$(( c * ( 100 - -1 * ( h % 2 - 100 ) ) ))"
	local m="$(( l - ( c / 2 ) ))"
	local a="$(( 0 <= h < 100 ? c : 100 <= h < 200 ? x : 200 <= h < 400 ? 0 : 400 <= h < 500 ? x : 500 <= h ? c : 0 ))"
	local b="$(( 0 <= h < 100 ? x : 100 <= h < 300 ? c : 300 <= h < 400 ? x : 400 <= h ? 0 : 0 ))"
	local c="$(( 0 <= h < 200 ? 0 : 200 <= h < 300 ? x : 300 <= h < 500 ? c : 500 <= h ? c : x ))"
	local out=(
		"$(( 255 * ( a + m ) / 100 ))"
		"$(( 255 * ( b + m ) / 100 ))"
		"$(( 255 * ( c + m ) / 100 ))"
	)
	echo "${out[@]}"
}

# Usage: reconstruct [red] [green] [blue]
# Outputs a full hexadecimal format color converted from color channel values
reconstruct() {
	printf '%s%02x%02x%02x\n' "#" "${1}" "${2}" "${3}"
}

# Print usage info
usage() {
	OLDIFS="$IFS"
	IFS=$'\n'
	read -rd '' "usage_doc" <<-'EOF'
		Usage: csg {OPTION} [color] [weight]
		Example: csg -c="~/documents/colors" -f #12271c 55 -g
		
		   Options:
		   	-c='/path/to/colors'	Load colorscheme to compare against from external file.
		   				Color0-15 should be listed in this file as strings in bash syntax.
		   	-f			Set color0 to the input color.
		   	-g			Generate hilights from color0-7.
		   	-h, --help		Display this message.
		
		   Arguments:
		   	color			A single color represented in hexadecimal format: '#FFFFFF'.
		   	weight			Value between 0 and 100, a higher number results in a
		   				color more closely resembling the input color.
		
		   Environment variables:
		   	CSG_DEBUG		If set to 'true' or '1', enter debug mode.
		
	EOF
	IFS="$OLDIFS"
	printf '%b\n' "$usage_doc"
}

main() {
	# Move args into an array so we can access per position
	for arg in "${@}"; do
		args+=("$arg")
	done
	for arg in "${!args[@]}"; do
		case "${args[$arg]}" in
			'-h'|'--help')
				usage
				exit 0
				;;
			'-f')
				COLOR0_SAME_AS_MASK="1"
				;;
			'-g')
				GENERATE_HIGHLIGHTS="1"
				;;
			'-c='*)
				# Try to source external colorscheme file
				COLOR_FILE="${args[$arg]}"
				COLOR_FILE="${COLOR_FILE##-c=}"
				[[ ! -e "$COLOR_FILE" ]] && {
					printf '%b\n' "Color file '$COLOR_FILE' not found."
					usage
					exit 1
				}|| . "$COLOR_FILE" || {
					printf '%b\n' "Colors in '$COLOR_FILE' not found or bad syntax."
					usage
					exit 1
				}
				;;
		esac
		# We will check for the input fields here, otherwise we would unset found opts and then pass ${args[@]} as input
		[[ "${args[$arg]}" =~ ^'#'[A-Fa-f0-9]{6}$ ]] && input="${args[$arg]}"
		[[ "${args[$arg]}" =~ ^[0-9]$|^[0-9][0-9]$|^[0-1][0]{1,2}$ ]] && strength="${args[$arg]}"
	done
	[[ -n "$input" ]] && [[ -n "$strength" ]] || {
		usage
		exit 1
	}
	declare -A oc
	# Deconstruct input color
	decon_ioutput=($(deconstruct_i "$input"))
	# Loop through colors 0-15
	for i in {0..15}; do
		# Check if '-f' was set
		[[ "$i" == "0" ]] && [[ "$COLOR0_SAME_AS_MASK" == "1" ]] && {
			oc["color$i"]="$input"
		} || {
			oc["color$i"]=$(
				decon_b16output=($(deconstruct_b16 "$i"))
				[[ "$i" -lt 8 ]] && {
					mergeoutput=($(merge "$strength" ${decon_ioutput[@]} ${decon_b16output[@]}))
					reconstruct "${mergeoutput[@]}"
				} || {
					mergeoutput=($(merge "$strength" ${decon_ioutput[@]} ${decon_b16output[@]}))
					# Check if '-g' was set
					[[ "$GENERATE_HIGHLIGHTS" == "1" ]] && {
						hilightoutput=($(hilight ${mergeoutput[@]}))
						reconstruct "${hilightoutput[@]}"
					} || reconstruct "${mergeoutput[@]}"
				}
			)
		}
	done
	wait
	# Output all generated colors in order
	for i in {0..15}; do
		echo "Color$i: ${oc[color$i]}"
	done
	exit 0
}

main "$@"
